// ==UserScript==
// @name         MorphoSource Advanced Search (exclude taxa)
// @namespace    https://www.morphosource.org/
// @version      0.1
// @description  Add an advanced search box to exclude taxa (e.g. "Carnivora except Felidae"). Hides results client-side by taxonomy text.
// @author       Generated by Copilot
// @match        https://www.morphosource.org/catalog/media*
// @grant        none
// @run-at       document-end
// ==/UserScript==

(function() {
    'use strict';

    // Utility: find taxonomy text for a result <li class="document">
    function getTaxonomyText(item) {
        try {
            // the structure: <dd class="col-9"><div><i>Genus species</i></div></dd>
            const dtNodes = item.querySelectorAll('dt');
            for (const dt of dtNodes) {
                if (dt.textContent && dt.textContent.trim().startsWith('Taxonomy')) {
                    const dd = dt.nextElementSibling;
                    if (!dd) return '';
                    // find italic or text inside
                    const italic = dd.querySelector('i');
                    if (italic) return italic.textContent.trim();
                    return dd.textContent.trim();
                }
            }
            // fallback: look for any <dd> with "Taxonomy:" preceding
            const taxonomyDd = Array.from(item.querySelectorAll('dd')).find(dd => dd.previousElementSibling && dd.previousElementSibling.textContent && dd.previousElementSibling.textContent.includes('Taxonomy'));
            if (taxonomyDd) {
                const i = taxonomyDd.querySelector('i');
                return i ? i.textContent.trim() : taxonomyDd.textContent.trim();
            }
        } catch (e) {
            console.error('getTaxonomyText error', e);
        }
        return '';
    }

    // Parse simple expressions like "Carnivora except Felidae, Ursidae"
    function parseExpression(input) {
        const raw = (input || '').trim();
        if (!raw) return { include: '', exclude: [] };
        // If the user used the word "except", keep previous behavior
        if (/\bexcept\b/i.test(raw)) {
            const parts = raw.split(/except/i);
            const include = parts[0] ? parts[0].trim() : '';
            // split excludes by comma/semicolon only so multi-word taxa stay intact
            const exclude = parts[1] ? parts[1].split(/[;,]+/).map(s => s.trim()).filter(Boolean) : [];
            return { include, exclude };
        }
        // If the user prefixed with - or ! treat as exclusion list: "-Felidae, -Ursidae" or "!Felidae"
        if (/^[!-]/.test(raw)) {
            const cleaned = raw.replace(/^[!-]+/, '').trim();
            // split by comma/semicolon only
            const exclude = cleaned.split(/[;,]+/).map(s => s.trim()).filter(Boolean);
            return { include: '', exclude };
        }
        // If the user provided a comma-separated list, treat those as excludes (commas are separators)
        if (raw.indexOf(',') !== -1 || raw.indexOf(';') !== -1) {
            const exclude = raw.split(/[;,]+/).map(s => s.trim()).filter(Boolean);
            return { include: '', exclude };
        }
        // If it's a single token (no spaces) assume the user wants to exclude that taxon (legacy behavior)
        if (!/\s+/.test(raw)) {
            return { include: '', exclude: [raw] };
        }
        // Otherwise treat as an include phrase
        return { include: raw, exclude: [] };
    }

    // Main filter routine
    function applyFilters(input) {
        const { include, exclude } = parseExpression(input);
        const items = document.querySelectorAll('li.document');
        const excludesLower = exclude.map(s => s.toLowerCase());
        let hiddenCount = 0;
        const hiddenTaxa = new Set(); // track unique taxa that were hidden

        // helper: check exclusion match as whole-token match
        function exclusionMatches(taxLower, exLower) {
            if (!taxLower || !exLower) return false;
            // if exclusion contains spaces, treat as a multi-word taxon and match exact substring
            if (/\s+/.test(exLower)) {
                return taxLower.indexOf(exLower) !== -1;
            }
            // Single-word exclusion: split taxonomy into tokens by non-letter characters and compare exact tokens.
            // But ensure taxa like 'Antrozous pallidus pallidus' are treated as a single taxon when matched by full string.
            const tokens = taxLower.split(/[^a-zA-Z]+/).map(t => t.trim()).filter(Boolean);
            return tokens.includes(exLower);
        }

        items.forEach(item => {
            const tax = getTaxonomyText(item) || '';
            const taxLower = tax.toLowerCase();
            let hide = false;
            // If include is provided, only show items containing include (in taxonomy or title)
            if (include) {
                const title = (item.querySelector('.search-result-title') ? item.querySelector('.search-result-title').textContent : '').toLowerCase();
                if (!taxLower.includes(include.toLowerCase()) && !title.includes(include.toLowerCase())) {
                    hide = true;
                }
            }
            // If taxonomy matches any excluded token, hide
            for (const ex of excludesLower) {
                if (!ex) continue;
                if (exclusionMatches(taxLower, ex)) {
                    hide = true;
                    break;
                }
            }

            item.style.display = hide ? 'none' : '';
            if (hide) {
                hiddenCount++;
                if (tax) hiddenTaxa.add(tax); // add original taxonomy text to set
            }
        });
        return { hiddenCount, hiddenTaxa: Array.from(hiddenTaxa).sort() };
    }

    function createUI() {
        console.log('MorphoSource Advanced Search: createUI() starting');
        // small helper: wait for selector
        function waitFor(selector, timeout = 5000) {
            return new Promise((resolve) => {
                const el = document.querySelector(selector);
                if (el) return resolve(el);
                const obs = new MutationObserver(() => {
                    const found = document.querySelector(selector);
                    if (found) {
                        obs.disconnect();
                        resolve(found);
                    }
                });
                obs.observe(document.documentElement, { childList: true, subtree: true });
                setTimeout(() => { obs.disconnect(); resolve(null); }, timeout);
            });
        }
        // find container above results. On the catalog page there's a div with class 'document-list' or a 'search-results' container
        const resultsContainer = document.querySelector('.document-list') || document.querySelector('.documents') || document.querySelector('.catalog-results') || document.querySelector('#documents');
        const listContainer = document.querySelector('ul.document-list') || document.querySelector('ul');

        // try to place the UI near the page's search form
    const searchBar = document.querySelector('form.blacklight-search') || document.querySelector('.catalog-search') || document.querySelector('.search-form');
    let anchor = searchBar || resultsContainer || document.querySelector('.container') || document.body;

    // Use site-like Bootstrap card and form classes so the injected UI blends in
    const outerCard = document.createElement('div');
    outerCard.className = 'card mb-3';

    // Collapsible header
    const collapsedKey = 'morphosource_advanced_search_collapsed';
    const headerDiv = document.createElement('div');
    headerDiv.className = 'card-header p-1 d-flex align-items-center justify-content-between';
    const headerTitle = document.createElement('span');
    headerTitle.style.fontWeight = '600';
    headerTitle.textContent = 'Advanced search';
    const toggleBtn = document.createElement('button');
    toggleBtn.type = 'button';
    toggleBtn.className = 'btn btn-sm btn-outline-secondary';
    toggleBtn.textContent = 'Hide';
    headerDiv.appendChild(headerTitle);
    headerDiv.appendChild(toggleBtn);

    const cardBody = document.createElement('div');
    cardBody.className = 'card-body p-2';

        const controls = document.createElement('div');
        controls.className = 'd-flex align-items-center flex-wrap';

        const label = document.createElement('label');
        label.textContent = 'Advanced search (use "except" for exclusions):';
        label.className = 'mr-2 mb-0';

        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'e.g. Carnivora except Felidae';
        input.className = 'form-control form-control-sm mr-2';
        input.style.minWidth = '240px';

        const btn = document.createElement('button');
        btn.textContent = 'Apply';
        btn.type = 'button';
        btn.className = 'btn btn-sm btn-primary mr-3';

        const hint = document.createElement('small');
        hint.textContent = 'Hides results client-side by taxonomy. Use comma/space to separate excludes. Prefix with "except" or start with "-" for explicit excludes.';
        hint.className = 'form-text text-muted w-100';

        const counter = document.createElement('div');
        counter.className = 'text-muted ml-2';
        counter.style.fontWeight = '600';
        counter.textContent = '';

    controls.appendChild(label);
        controls.appendChild(input);
        controls.appendChild(btn);
        controls.appendChild(counter);
        cardBody.appendChild(controls);
        cardBody.appendChild(hint);
    // assemble card with header and body
    outerCard.appendChild(headerDiv);
    outerCard.appendChild(cardBody);
        const box = outerCard;

        // (already appended into the composed 'box' widget above)

        // Try to insert near the search form or results; fall back to visible prepend
        try {
            if (anchor && anchor.parentNode) {
                anchor.parentNode.insertBefore(box, anchor.nextSibling);
            } else {
                document.body.prepend(box);
            }
        } catch (e) {
            console.warn('MorphoSource Advanced Search: insertion fallback', e);
            document.body.prepend(box);
        }

        // load saved last query from sessionStorage
        const storageKey = 'morphosource_advanced_search_query';
        const last = sessionStorage.getItem(storageKey);
        if (last) input.value = last;

        // initialize collapse state
        const collapsed = sessionStorage.getItem(collapsedKey) === '1';
        if (collapsed) {
            cardBody.style.display = 'none';
            toggleBtn.textContent = 'Show';
        }
        toggleBtn.addEventListener('click', () => {
            const nowHidden = cardBody.style.display === 'none';
            if (nowHidden) {
                cardBody.style.display = '';
                toggleBtn.textContent = 'Hide';
                sessionStorage.setItem(collapsedKey, '0');
            } else {
                cardBody.style.display = 'none';
                toggleBtn.textContent = 'Show';
                sessionStorage.setItem(collapsedKey, '1');
            }
        });

        function doApply() {
            const val = input.value || '';
            sessionStorage.setItem(storageKey, val);
            const result = applyFilters(val);
            console.log('MorphoSource Advanced Search: applyFilters ran, hidden=', result.hiddenCount);
            
            // Build counter text with list of hidden taxa
            if (result.hiddenCount > 0) {
                const taxaList = result.hiddenTaxa.length > 0 
                    ? ` (${result.hiddenTaxa.join(', ')})` 
                    : '';
                counter.textContent = `${result.hiddenCount} result(s) hidden${taxaList}`;
                counter.title = result.hiddenTaxa.length > 0 
                    ? `Hidden taxa: ${result.hiddenTaxa.join(', ')}` 
                    : '';
            } else {
                counter.textContent = 'No results hidden';
                counter.title = '';
            }
        }

        // Inject "Add exclusion" buttons next to taxonomy fields in each result item
        function addExcludeButtons() {
            const items = document.querySelectorAll('li.document');
            items.forEach(item => {
                try {
                    // find the dd that follows a dt containing 'Taxonomy'
                    const dt = Array.from(item.querySelectorAll('dt')).find(d => d.textContent && d.textContent.trim().startsWith('Taxonomy'));
                    let dd = dt ? dt.nextElementSibling : null;
                    if (!dd) {
                        // fallback: find any dd which previous sibling contains 'Taxonomy'
                        dd = Array.from(item.querySelectorAll('dd')).find(d => d.previousElementSibling && d.previousElementSibling.textContent && d.previousElementSibling.textContent.includes('Taxonomy'));
                    }
                    if (!dd) return;
                    // allow re-attachment if button missing inside
                    const innerDiv = dd.querySelector('div') || dd;
                    const existing = innerDiv.querySelector('.ms-add-exclude-btn');
                    if (existing) return;

                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'btn btn-sm btn-outline-secondary ms-add-exclude-btn';
                    btn.style.fontSize = '0.8rem';
                    btn.style.marginLeft = '8px';
                    btn.textContent = 'Add exclusion';
                    btn.setAttribute('aria-label', 'Add this taxonomy to exclusions');

                    btn.addEventListener('click', (ev) => {
                        ev.preventDefault();
                        const taxText = getTaxonomyText(item);
                        if (!taxText) return;
                        addExclusionChip(taxText);
                        // visual feedback
                        const old = btn.textContent;
                        btn.textContent = 'Added';
                        setTimeout(() => { btn.textContent = old; }, 900);
                    });

                    innerDiv.appendChild(btn);
                } catch (e) {
                    // don't break other scripts
                    console.debug('addExcludeButtons error', e);
                }
            });
        }

        // Chips container (placed inside taxonomy facet card)
        let chipsContainer = null;
        let currentExcludes = [];

        function ensureChipsContainer() {
            if (chipsContainer) return chipsContainer;
            // Prefer to insert a new facet card under #facets (the left pane)
            const facetsPane = document.querySelector('#facets');
            if (facetsPane) {
                // avoid duplicating
                const existingCard = facetsPane.querySelector('.card.facet-limit.blacklight-exclusions');
                if (existingCard) {
                    const existingContainer = existingCard.querySelector('.ms-exclusions');
                    if (existingContainer) { chipsContainer = existingContainer; return chipsContainer; }
                }

                // Build a facet-like card matching site structure
                const card = document.createElement('div');
                card.className = 'card facet-limit blacklight-exclusions';

                const header = document.createElement('h3');
                header.className = 'card-header p-0 facet-field-heading';
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'btn w-100 d-block btn-block p-2 text-start text-left collapse-toggle collapsed';
                btn.setAttribute('data-toggle', 'collapse');
                btn.setAttribute('data-bs-toggle', 'collapse');
                btn.setAttribute('data-target', '#facet-exclusions');
                btn.setAttribute('data-bs-target', '#facet-exclusions');
                btn.setAttribute('aria-expanded', 'false');
                btn.innerHTML = 'Exclusions';
                header.appendChild(btn);

                const collapse = document.createElement('div');
                collapse.id = 'facet-exclusions';
                collapse.className = 'panel-collapse facet-content collapse';
                const body = document.createElement('div');
                body.className = 'card-body';

                const container = document.createElement('div');
                container.className = 'ms-exclusions d-flex flex-wrap';
                body.appendChild(container);
                collapse.appendChild(body);

                card.appendChild(header);
                card.appendChild(collapse);

                // Insert near top of facets pane, after facets header if present
                const facetsHeader = facetsPane.querySelector('.facets-header');
                if (facetsHeader && facetsHeader.parentNode) facetsHeader.parentNode.insertBefore(card, facetsHeader.nextSibling);
                else facetsPane.prepend(card);

                chipsContainer = container;
                return chipsContainer;
            }
            // fallback: null
            return null;
        }

        function renderChips() {
            const container = ensureChipsContainer();
            if (!container) return;
            container.innerHTML = '';
            currentExcludes.forEach(t => {
                // Build structure matching site's constraint-value with remove link
                const wrapper = document.createElement('span');
                wrapper.className = 'constraint-value btn btn-outline-secondary mr-1 mb-1';

                const fvalue = document.createElement('span');
                fvalue.className = 'filter-value';
                fvalue.title = t;
                fvalue.textContent = t;

                const a = document.createElement('a');
                a.className = 'ml-1 remove-btn';
                a.href = '#';
                a.setAttribute('aria-label', `Remove exclusion ${t}`);
                a.addEventListener('click', (ev) => {
                    ev.preventDefault();
                    removeExclusionChip(t);
                });

                const icon = document.createElement('span');
                icon.className = 'fas fa-times-circle';
                icon.setAttribute('aria-hidden', 'true');

                const sr = document.createElement('span');
                sr.className = 'sr-only visually-hidden';
                sr.textContent = `Remove constraint ${t}`;

                a.appendChild(icon);
                a.appendChild(sr);

                wrapper.appendChild(fvalue);
                wrapper.appendChild(a);

                container.appendChild(wrapper);
            });
        }

        function normalizeTaxon(t) {
            return (t || '').trim();
        }

        function addExclusionChip(taxon) {
            if (!taxon) return;
            const clean = normalizeTaxon(taxon);
            const lower = clean.toLowerCase();
            if (currentExcludes.map(e => e.toLowerCase()).includes(lower)) return;
            currentExcludes.push(clean);
            renderChips();
            // sync input
            const parsed = parseExpression(input.value || '');
            if (parsed.include) {
                input.value = `${parsed.include} except ${currentExcludes.join(', ')}`;
            } else {
                input.value = currentExcludes.join(', ');
            }
            sessionStorage.setItem(storageKey, input.value);
            doApply();
        }

        function removeExclusionChip(taxon) {
            const lower = (taxon || '').toLowerCase();
            currentExcludes = currentExcludes.filter(e => e.toLowerCase() !== lower);
            renderChips();
            const parsed = parseExpression(input.value || '');
            if (parsed.include) {
                input.value = `${parsed.include} except ${currentExcludes.join(', ')}`;
            } else {
                input.value = currentExcludes.join(', ');
            }
            sessionStorage.setItem(storageKey, input.value);
            doApply();
        }

        function loadChipsFromInput() {
            const parsed = parseExpression(input.value || '');
            // keep the exact phrases as parsed (parseExpression already splits only on commas/semicolons)
            currentExcludes = parsed.exclude ? parsed.exclude.map(normalizeTaxon) : [];
            renderChips();
        }

        btn.addEventListener('click', doApply);
        input.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); doApply(); } });
        input.addEventListener('change', () => { loadChipsFromInput(); });

        // Also reapply when results change (pagination or AJAX) using MutationObserver
        const target = listContainer || document.querySelector('div.search-results') || document.body;
        const mo = new MutationObserver(() => {
            // small debounce
            if (window.__morpho_filter_timeout) clearTimeout(window.__morpho_filter_timeout);
            window.__morpho_filter_timeout = setTimeout(() => { 
                const result = applyFilters(input.value || '');
                // Update counter when filters reapply
                if (result.hiddenCount > 0) {
                    const taxaList = result.hiddenTaxa.length > 0 
                        ? ` (${result.hiddenTaxa.join(', ')})` 
                        : '';
                    counter.textContent = `${result.hiddenCount} result(s) hidden${taxaList}`;
                    counter.title = result.hiddenTaxa.length > 0 
                        ? `Hidden taxa: ${result.hiddenTaxa.join(', ')}` 
                        : '';
                } else {
                    counter.textContent = 'No results hidden';
                    counter.title = '';
                }
            }, 200);
            // ensure add-exclude buttons exist on newly added results
            if (window.__morpho_btn_timeout) clearTimeout(window.__morpho_btn_timeout);
            window.__morpho_btn_timeout = setTimeout(() => { addExcludeButtons(); loadChipsFromInput(); }, 300);
        });
        mo.observe(target, { childList: true, subtree: true });

        // initial apply, attach buttons and load chips
        setTimeout(() => { doApply(); addExcludeButtons(); loadChipsFromInput(); }, 300);

        // expose helpers for debugging from the console
        try {
            window.__morpho_applyFilters = applyFilters;
            window.__morpho_createUI = createUI;
        } catch (e) { /* non-critical */ }
    }

    // only run on the catalog list pages
    if (window.location.pathname.startsWith('/catalog/media')) {
        // Wait for DOM content
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', createUI);
        } else {
            createUI();
        }
    }

})();
