// ==UserScript==
// @name         MorphoSource Extended Taxonomy (GBIF)
// @namespace    https://www.morphosource.org/
// @version      0.1
// @description  Show extended taxonomy (family, order) next to taxonomy using GBIF API (search by genus = first word)
// @author       Generated by Copilot
// @match        https://www.morphosource.org/catalog/media*
// @match        https://www.morphosource.org/concern/media/*
// @match        https://www.morphosource.org/organizations/*
// @grant        GM_xmlhttpRequest
// @run-at       document-end
// ==/UserScript==

(function() {
    'use strict';

    // Config: endpoints
    const GBIF_MATCH = 'https://api.gbif.org/v1/species/match';
    const GBIF_SPECIES = 'https://api.gbif.org/v1/species';

    // simple in-memory cache + optional sessionStorage persisted cache
    const cache = new Map();
    const STORAGE_KEY = 'morpho_gbif_cache_v1';

    function loadCache() {
        try {
            const raw = sessionStorage.getItem(STORAGE_KEY);
            if (!raw) return;
            const obj = JSON.parse(raw);
            Object.entries(obj).forEach(([k,v]) => cache.set(k,v));
        } catch (e) { /* ignore */ }
    }
    function saveCache() {
        try {
            const obj = Object.fromEntries(cache.entries());
            sessionStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
        } catch (e) { /* ignore */ }
    }

    // Query GBIF for a name (species or genus). Try full name first, fall back to genus-only.
    async function fetchGbifForName(name) {
        if (!name) return { family: null, order: null, class: null, scientific: name, confidence: 0 };
        const key = name.toLowerCase();
        if (cache.has(key)) {
            return cache.get(key);
        }
        // helper: normalize by removing author, extra parens, and limiting to two words
        function normalizeName(n) {
            if (!n) return n;
            // remove HTML entities/spans etc
            n = n.replace(/<[^>]+>/g, '');
            // remove content inside parentheses (authors)
            n = n.replace(/\([^)]*\)/g, '');
            // collapse whitespace
            n = n.replace(/\s+/g, ' ').trim();
            // remove trailing commas
            n = n.replace(/,$/, '');
            // split into parts
            const parts = n.split(/\s+/);
            // Handle repeated genus: if first two tokens are identical (case-insensitive), skip the first
            // e.g., "Panthera Panthera pardus" -> "Panthera pardus"
            if (parts.length >= 3 && parts[0].toLowerCase() === parts[1].toLowerCase()) {
                return `${parts[1]} ${parts[2]}`;
            }
            // limit to genus + species (first two tokens)
            if (parts.length >= 2) return `${parts[0]} ${parts[1]}`;
            return parts[0] || n;
        }

        function removeDiacritics(str) {
            if (!str) return str;
            return str.normalize('NFD').replace(/\p{Diacritic}/gu, '');
        }

        const normalized = removeDiacritics(normalizeName(name));
        try {
            // First try the full name
            const fullUrl = GBIF_MATCH + '?name=' + encodeURIComponent(normalized);
            console.debug('GBIF: querying match for', normalized, 'original:', name);
            const fullResp = await fetch(fullUrl);
            if (fullResp.ok) {
                const js = await fullResp.json();
                console.debug('GBIF match response for', normalized, js);
                // If we got family/order/class from this match, use it
                if (js.family || js.order || js.class) {
                    const out = { family: js.family || null, order: js.order || null, class: js.class || null, scientific: js.scientificName || name, confidence: js.confidence || 0 };
                    cache.set(key, out);
                    saveCache();
                    return out;
                }
                // follow acceptedUsageKey or acceptedKey if present
                if (js.synonym && js.acceptedUsageKey) {
                    const accUrl = `${GBIF_SPECIES}/${js.acceptedUsageKey}`;
                    const accResp = await fetch(accUrl);
                    if (accResp.ok) {
                        const accJs = await accResp.json();
                        const out = { family: accJs.family || null, order: accJs.order || null, class: accJs.class || null, scientific: accJs.scientificName || name, confidence: 90 };
                        cache.set(key, out);
                        saveCache();
                        return out;
                    }
                }
                if (js.matchType === 'NONE' && js.acceptedKey) {
                    const accUrl = `${GBIF_SPECIES}/${js.acceptedKey}`;
                    const accResp = await fetch(accUrl);
                    if (accResp.ok) {
                        const accJs = await accResp.json();
                        const out = { family: accJs.family || null, order: accJs.order || null, class: accJs.class || null, scientific: accJs.scientificName || name, confidence: 85 };
                        cache.set(key, out);
                        saveCache();
                        return out;
                    }
                }
            }
        } catch (e) {
            console.error('GBIF full-name fetch error for', name, e);
        }
        // If full name didn't give us family/order/class, try a species search as a fallback
        try {
            const searchUrl = `https://api.gbif.org/v1/species/search?q=${encodeURIComponent(normalized)}&limit=5`;
            console.debug('GBIF: searching species for', normalized, searchUrl);
            const sResp = await fetch(searchUrl);
            if (sResp.ok) {
                const sJs = await sResp.json();
                console.debug('GBIF search results for', normalized, sJs);
                if (sJs && Array.isArray(sJs.results) && sJs.results.length > 0) {
                    // prefer exact canonicalName matches
                    let candidate = sJs.results.find(r => (r.canonicalName && r.canonicalName.toLowerCase() === normalized.toLowerCase()) || (r.scientificName && r.scientificName.toLowerCase() === normalized.toLowerCase()));
                    if (!candidate) {
                        // Otherwise, try to pick a candidate that matches the original genus (if present) and is a mammal/species
                        const originalGenus = normalized.split(/\s+/)[0].toLowerCase();
                        const genusMatches = sJs.results.filter(r => r.genus && r.genus.toLowerCase() === originalGenus && r.rank === 'SPECIES');
                        if (genusMatches.length > 0) candidate = genusMatches[0];
                    }
                    if (!candidate) {
                        // Prefer candidates from the same genus (already done), otherwise prefer candidates
                        // from the most common class among the search results (mode), favoring rank=SPECIES and ACCEPTED
                        const classCounts = {};
                        sJs.results.forEach(r => {
                            if (r.class) {
                                const c = String(r.class).toLowerCase();
                                classCounts[c] = (classCounts[c] || 0) + 1;
                            }
                        });
                        const classMode = Object.keys(classCounts).sort((a,b) => classCounts[b]-classCounts[a])[0];
                        if (classMode) {
                            const classCandidates = sJs.results.filter(r => r.class && String(r.class).toLowerCase() === classMode && r.rank === 'SPECIES' && r.taxonomicStatus && r.taxonomicStatus.toUpperCase() === 'ACCEPTED');
                            if (classCandidates.length > 0) candidate = classCandidates[0];
                        }
                    }
                    if (!candidate) candidate = sJs.results.find(r => r.rank === 'SPECIES' && r.taxonomicStatus && r.taxonomicStatus.toUpperCase() === 'ACCEPTED') || sJs.results[0];
                    if (candidate && candidate.key) {
                        console.debug('GBIF: chosen search candidate', candidate.key, candidate.canonicalName || candidate.scientificName, candidate.class, candidate.family, candidate.score);
                        const detailUrl = `${GBIF_SPECIES}/${candidate.key}`;
                        const dResp = await fetch(detailUrl);
                        if (dResp.ok) {
                            const dJs = await dResp.json();
                            const out = { family: dJs.family || null, order: dJs.order || null, class: dJs.class || null, scientific: dJs.scientificName || candidate.canonicalName || name, confidence: candidate.score || 80 };
                            cache.set(key, out);
                            saveCache();
                            return out;
                        }
                    }
                }
            }
        } catch (e) {
            console.error('GBIF search fallback error for', name, e);
        }

        // If species search didn't help, fall back to genus-only
        const genus = normalized.trim().split(/\s+/)[0];
        if (genus && genus.toLowerCase() !== name.toLowerCase()) {
            // try genus lookup using existing logic
            return await fetchGbifForGenus(genus);
        }
        const empty = { family: null, order: null, class: null, scientific: name, confidence: 0 };
        cache.set(key, empty);
        saveCache();
        return empty;
    }

    // Query GBIF for a genus name, return {family, order, class, scientificName, confidence}
    async function fetchGbifForGenus(genus) {
        const key = genus.toLowerCase();
        if (cache.has(key)) {
            return cache.get(key);
        }
        try {
            // Use species/match - it returns family/order/class directly
            const url = GBIF_MATCH + '?name=' + encodeURIComponent(genus);
            const resp = await fetch(url);
            if (!resp.ok) throw new Error('GBIF match failed');
            const js = await resp.json();
            
            // If we have a synonym (acceptedUsageKey), follow it
            if (js.synonym && js.acceptedUsageKey) {
                console.log(`GBIF: ${genus} is a synonym, following acceptedUsageKey: ${js.acceptedUsageKey}`);
                const accUrl = `${GBIF_SPECIES}/${js.acceptedUsageKey}`;
                const accResp = await fetch(accUrl);
                if (accResp.ok) {
                    const accJs = await accResp.json();
                    const out = {
                        family: accJs.family || null,
                        order: accJs.order || null,
                        class: accJs.class || null,
                        scientific: accJs.scientificName || genus,
                        confidence: 90 // synonym match
                    };
                    cache.set(key, out);
                    saveCache();
                    return out;
                }
            }
            
            // If match is NONE but record has acceptedKey, follow it
            if (js.matchType === 'NONE' && js.acceptedKey) {
                console.log(`GBIF: ${genus} matchType NONE but has acceptedKey: ${js.acceptedKey}`);
                const accUrl = `${GBIF_SPECIES}/${js.acceptedKey}`;
                const accResp = await fetch(accUrl);
                if (accResp.ok) {
                    const accJs = await accResp.json();
                    const out = {
                        family: accJs.family || null,
                        order: accJs.order || null,
                        class: accJs.class || null,
                        scientific: accJs.scientificName || genus,
                        confidence: 85
                    };
                    cache.set(key, out);
                    saveCache();
                    return out;
                }
            }
            
            // Extract data directly from match response
            const family = js.family || null;
            const order = js.order || null;
            const classVal = js.class || null;
            const scientific = js.scientificName || genus;
            const confidence = js.confidence || 0;
            
            const out = { family, order, class: classVal, scientific, confidence };
            cache.set(key, out);
            saveCache();
            return out;
        } catch (e) {
            console.error('GBIF fetch error for', genus, e);
        }
        const empty = { family: null, order: null, class: null, scientific: genus, confidence: 0 };
        cache.set(key, empty);
        saveCache();
        return empty;
    }

    function getGenusFromTaxonomy(taxText) {
        if (!taxText) return null;
        const first = taxText.trim().split(/\s+/)[0];
        return first || null;
    }

    // Insert extended taxonomy node after the existing taxonomy dd or next to it.
    function attachExtended(node, info) {
        try {
            // avoid duplicating - check if next siblings already have GBIF data
            let sibling = node.nextSibling;
            while (sibling) {
                if (sibling.classList && sibling.classList.contains('ms-extended-taxonomy-row')) {
                    return; // already exists
                }
                if (sibling.tagName === 'DT') break; // found next dt, stop checking
                sibling = sibling.nextSibling;
            }
            
            // Only show if we have data
            if (!info.family && !info.order && !info.class) {
                return;
            }
            
            // Insert rows in the same style as the site: dt (label) + dd (value)
            const rowsToInsert = [];
            
            if (info.family) {
                const dt = document.createElement('dt');
                dt.className = 'col-3 text-left ms-extended-taxonomy-row';
                dt.textContent = 'Family:';
                const dd = document.createElement('dd');
                dd.className = 'col-9 ms-extended-taxonomy-row';
                dd.innerHTML = `<div>${info.family}</div>`;
                rowsToInsert.push(dt, dd);
            }
            
            if (info.order) {
                const dt = document.createElement('dt');
                dt.className = 'col-3 text-left ms-extended-taxonomy-row';
                dt.textContent = 'Order:';
                const dd = document.createElement('dd');
                dd.className = 'col-9 ms-extended-taxonomy-row';
                dd.innerHTML = `<div>${info.order}</div>`;
                rowsToInsert.push(dt, dd);
            }
            
            if (info.class) {
                const dt = document.createElement('dt');
                dt.className = 'col-3 text-left ms-extended-taxonomy-row';
                dt.textContent = 'Class:';
                const dd = document.createElement('dd');
                dd.className = 'col-9 ms-extended-taxonomy-row';
                dd.innerHTML = `<div>${info.class}</div>`;
                rowsToInsert.push(dt, dd);
            }
            
            // Insert all rows after the taxonomy dd node
            if (node.parentNode && rowsToInsert.length > 0) {
                let insertAfter = node;
                rowsToInsert.forEach(row => {
                    insertAfter.parentNode.insertBefore(row, insertAfter.nextSibling);
                    insertAfter = row;
                });
            }
        } catch (e) {
            console.error('attachExtended error', e);
        }
    }

    // Insert extended taxonomy for show-page row layout (div.row with .showcase-label / .showcase-value)
    function attachExtendedRow(labelDiv, valueDiv, info) {
        try {
            // labelDiv is the left column, valueDiv is the right column inside a .row
            const row = labelDiv.closest('.row');
            if (!row) return;

            // avoid duplicating - check next sibling rows
            let next = row.nextElementSibling;
            while (next) {
                if (next.classList && next.classList.contains('ms-extended-taxonomy-row')) return; // already exists
                // stop if we reach another main field row (assume labels are showcase-label)
                if (next.querySelector && next.querySelector('.showcase-label')) break;
                next = next.nextElementSibling;
            }

            // Only show if we have data
            if (!info.family && !info.order && !info.class) return;

            const rowsToInsert = [];

            function makeRow(labelText, valueText) {
                const r = document.createElement('div');
                r.className = 'row ms-extended-taxonomy-row';
                const l = document.createElement('div');
                l.className = 'col-6 showcase-label';
                l.textContent = labelText;
                const v = document.createElement('div');
                v.className = 'col-6 showcase-value';
                const inner = document.createElement('div');
                inner.textContent = valueText;
                v.appendChild(inner);
                r.appendChild(l);
                r.appendChild(v);
                return r;
            }

            if (info.family) rowsToInsert.push(makeRow('Family', info.family));
            if (info.order) rowsToInsert.push(makeRow('Order', info.order));
            if (info.class) rowsToInsert.push(makeRow('Class', info.class));

            // Insert after the current row
            let insertAfter = row;
            rowsToInsert.forEach(r => {
                insertAfter.parentNode.insertBefore(r, insertAfter.nextSibling);
                insertAfter = r;
            });
        } catch (e) {
            console.error('attachExtendedRow error', e);
        }
    }

    // Insert extended taxonomy into a table cell (for organization specimen tables)
    function attachExtendedToCell(cell, info) {
        try {
            // avoid duplicating
            if (cell.querySelector('.ms-extended-taxonomy-cell')) return;

            // Only show if we have data
            if (!info.family && !info.order && !info.class) return;

            const container = document.createElement('div');
            container.className = 'ms-extended-taxonomy-cell';
            container.style.fontSize = '0.85em';
            container.style.marginTop = '4px';
            container.style.color = '#666';

            const parts = [];
            if (info.family) parts.push(`Family: ${info.family}`);
            if (info.order) parts.push(`Order: ${info.order}`);
            if (info.class) parts.push(`Class: ${info.class}`);

            container.innerHTML = parts.join('<br>');
            cell.appendChild(container);
        } catch (e) {
            console.error('attachExtendedToCell error', e);
        }
    }

    async function processAll() {
        loadCache();
        // Process search/listing items (li.document)
        const items = document.querySelectorAll('li.document');
        for (const item of items) {
            try {
                // skip items we've already annotated
                if (item.dataset && item.dataset.msGbif === '1') {
                    continue;
                }

                const tax = (function() {
                    // reuse previous logic: dt with Taxonomy then dd
                    const dt = Array.from(item.querySelectorAll('dt')).find(d => d.textContent && d.textContent.trim().startsWith('Taxonomy'));
                    const dd = dt ? dt.nextElementSibling : null;
                    if (dd) {
                        const i = dd.querySelector('i');
                        return i ? i.textContent.trim() : dd.textContent.trim();
                    }
                    const fallback = Array.from(item.querySelectorAll('dd')).find(d => d.previousElementSibling && d.previousElementSibling.textContent && d.previousElementSibling.textContent.includes('Taxonomy'));
                    if (fallback) return (fallback.querySelector('i') ? fallback.querySelector('i').textContent.trim() : fallback.textContent.trim());
                    return null;
                })();

                const genus = getGenusFromTaxonomy(tax);

                if (!genus) {
                    continue;
                }

                // prefer full taxonomy string when available to get species-level matches
                const info = await fetchGbifForName(tax || genus);

                // attach next to the taxonomy dd (reuse earlier found dd if possible)
                const dt = Array.from(item.querySelectorAll('dt')).find(d => d.textContent && d.textContent.trim().startsWith('Taxonomy'));
                const dd = dt ? dt.nextElementSibling : null;
                const attachNode = dd || (Array.from(item.querySelectorAll('dd')).find(d => d.previousElementSibling && d.previousElementSibling.textContent && d.previousElementSibling.textContent.includes('Taxonomy')));

                if (attachNode) {
                    attachExtended(attachNode, info);
                    try { item.dataset.msGbif = '1'; } catch (e) { /* ignore */ }
                }
            } catch (e) {
                console.error('GBIF processAll item error', e);
            }
        }

        // Additionally, if we're on an individual media page (General details), find the Taxonomy field and attach there
        try {
            // The item/show page uses a dl list with dt labels like 'General details' and nested dts/dds.
            // Find any dt that contains 'Taxonomy' text (case-insensitive) within the document and that is part of the general details area.
            const dtAll = Array.from(document.querySelectorAll('dt'));
            for (const dt of dtAll) {
                try {
                    if (!dt.textContent) continue;
                    const txt = dt.textContent.trim();
                    if (!/Taxonomy/i.test(txt)) continue;

                    // determine the dd with the taxonomy value
                    const dd = dt.nextElementSibling;
                    if (!dd) continue;

                    // avoid adding multiple times
                    let parentLi = dt.closest('li.document');
                    if (parentLi && parentLi.dataset && parentLi.dataset.msGbif === '1') continue;

                    const taxText = (dd.querySelector('i') ? dd.querySelector('i').textContent.trim() : dd.textContent.trim());
                    const genus = getGenusFromTaxonomy(taxText);
                    if (!genus) continue;

                    const info = await fetchGbifForName(taxText || genus);
                    attachExtended(dd, info);
                    try { if (parentLi) parentLi.dataset.msGbif = '1'; } catch (e) { /* ignore */ }
                } catch (e) { /* ignore per-dt errors */ }
            }
        } catch (e) {
            console.error('GBIF processAll page-level taxonomy error', e);
        }

        // Also support the .row / .showcase-label layout used in some media pages
        try {
            const labels = Array.from(document.querySelectorAll('.showcase-label'));
            for (const labelDiv of labels) {
                try {
                    const txt = labelDiv.textContent && labelDiv.textContent.trim();
                    if (!txt) continue;
                    if (!/Taxonomy/i.test(txt)) continue; // match 'Object taxonomy' or similar

                    // find the adjacent value column
                    const row = labelDiv.closest('.row');
                    if (!row) continue;
                    const valueDiv = row.querySelector('.showcase-value');
                    if (!valueDiv) continue;

                    // avoid duplicates
                    if (row.nextElementSibling && row.nextElementSibling.classList && row.nextElementSibling.classList.contains('ms-extended-taxonomy-row')) continue;

                    const taxText = (valueDiv.querySelector('i') ? valueDiv.querySelector('i').textContent.trim() : valueDiv.textContent.trim());
                    const genus = getGenusFromTaxonomy(taxText);
                    if (!genus) continue;
                    const info = await fetchGbifForName(taxText || genus);
                    attachExtendedRow(labelDiv, valueDiv, info);
                } catch (e) { /* ignore per-label errors */ }
            }
        } catch (e) {
            console.error('GBIF processAll showcase-row error', e);
        }

        // Also support organization specimen tables (tr with taxonomy in td > i)
        try {
            const rows = document.querySelectorAll('tr[id^="document_"]');
            console.debug('GBIF: found', rows.length, 'table rows with document_ id');
            for (const row of rows) {
                try {
                    // skip rows we've already annotated
                    if (row.dataset && row.dataset.msGbif === '1') continue;

                    // Find the cell with taxonomy (usually contains an <i> tag with the scientific name)
                    const cells = Array.from(row.querySelectorAll('td'));
                    let taxonomyCell = null;
                    let taxText = null;

                    for (const cell of cells) {
                        const italicTag = cell.querySelector('i');
                        if (italicTag && italicTag.textContent.trim()) {
                            // Check if it looks like a scientific name (at least one space, starts with capital)
                            const text = italicTag.textContent.trim();
                            if (/^[A-Z][a-z]+\s+/.test(text)) {
                                taxonomyCell = cell;
                                taxText = text;
                                console.debug('GBIF: found taxonomy in row', row.id, ':', text);
                                break;
                            }
                        }
                    }

                    if (!taxonomyCell || !taxText) {
                        console.debug('GBIF: no taxonomy cell found in row', row.id);
                        continue;
                    }

                    const genus = getGenusFromTaxonomy(taxText);
                    if (!genus) continue;

                    const info = await fetchGbifForName(taxText || genus);
                    console.debug('GBIF: fetched info for', taxText, ':', info);
                    attachExtendedToCell(taxonomyCell, info);
                    try { row.dataset.msGbif = '1'; } catch (e) { /* ignore */ }
                } catch (e) {
                    console.error('GBIF processAll table row error', e);
                }
            }
        } catch (e) {
            console.error('GBIF processAll table error', e);
        }
    }

    // observe mutations and process newly added results
    const mo = new MutationObserver((mutations) => {
        // small debounce
        if (window.__morpho_gbif_timeout) clearTimeout(window.__morpho_gbif_timeout);
        window.__morpho_gbif_timeout = setTimeout(() => { processAll(); }, 500);
    });
    mo.observe(document.body, { childList: true, subtree: true });

    // run once - longer delay for DataTables to load
    setTimeout(() => { processAll(); }, 1000);
    // run again after a bit more time if DataTables is slow
    setTimeout(() => { processAll(); }, 2000);

})();
