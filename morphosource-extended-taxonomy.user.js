// ==UserScript==
// @name         MorphoSource Extended Taxonomy (GBIF)
// @namespace    https://www.morphosource.org/
// @version      0.1
// @description  Show extended taxonomy (family, order) next to taxonomy using GBIF API (search by genus = first word)
// @author       Generated by Copilot
// @match        https://www.morphosource.org/catalog/media*
// @match        https://www.morphosource.org/concern/media/*
// @grant        GM_xmlhttpRequest
// @run-at       document-end
// ==/UserScript==

(function() {
    'use strict';

    // Config: endpoints
    const GBIF_MATCH = 'https://api.gbif.org/v1/species/match';
    const GBIF_SPECIES = 'https://api.gbif.org/v1/species';

    // simple in-memory cache + optional sessionStorage persisted cache
    const cache = new Map();
    const STORAGE_KEY = 'morpho_gbif_cache_v1';

    function loadCache() {
        try {
            const raw = sessionStorage.getItem(STORAGE_KEY);
            if (!raw) return;
            const obj = JSON.parse(raw);
            Object.entries(obj).forEach(([k,v]) => cache.set(k,v));
        } catch (e) { /* ignore */ }
    }
    function saveCache() {
        try {
            const obj = Object.fromEntries(cache.entries());
            sessionStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
        } catch (e) { /* ignore */ }
    }

    // Query GBIF for a genus name, return {family, order, class, scientificName, confidence}
    async function fetchGbifForGenus(genus) {
        const key = genus.toLowerCase();
        if (cache.has(key)) {
            return cache.get(key);
        }
        try {
            // Use species/match - it returns family/order/class directly
            const url = GBIF_MATCH + '?name=' + encodeURIComponent(genus);
            const resp = await fetch(url);
            if (!resp.ok) throw new Error('GBIF match failed');
            const js = await resp.json();
            
            // If we have a synonym (acceptedUsageKey), follow it
            if (js.synonym && js.acceptedUsageKey) {
                console.log(`GBIF: ${genus} is a synonym, following acceptedUsageKey: ${js.acceptedUsageKey}`);
                const accUrl = `${GBIF_SPECIES}/${js.acceptedUsageKey}`;
                const accResp = await fetch(accUrl);
                if (accResp.ok) {
                    const accJs = await accResp.json();
                    const out = {
                        family: accJs.family || null,
                        order: accJs.order || null,
                        class: accJs.class || null,
                        scientific: accJs.scientificName || genus,
                        confidence: 90 // synonym match
                    };
                    cache.set(key, out);
                    saveCache();
                    return out;
                }
            }
            
            // If match is NONE but record has acceptedKey, follow it
            if (js.matchType === 'NONE' && js.acceptedKey) {
                console.log(`GBIF: ${genus} matchType NONE but has acceptedKey: ${js.acceptedKey}`);
                const accUrl = `${GBIF_SPECIES}/${js.acceptedKey}`;
                const accResp = await fetch(accUrl);
                if (accResp.ok) {
                    const accJs = await accResp.json();
                    const out = {
                        family: accJs.family || null,
                        order: accJs.order || null,
                        class: accJs.class || null,
                        scientific: accJs.scientificName || genus,
                        confidence: 85
                    };
                    cache.set(key, out);
                    saveCache();
                    return out;
                }
            }
            
            // Extract data directly from match response
            const family = js.family || null;
            const order = js.order || null;
            const classVal = js.class || null;
            const scientific = js.scientificName || genus;
            const confidence = js.confidence || 0;
            
            const out = { family, order, class: classVal, scientific, confidence };
            cache.set(key, out);
            saveCache();
            return out;
        } catch (e) {
            console.error('GBIF fetch error for', genus, e);
        }
        const empty = { family: null, order: null, class: null, scientific: genus, confidence: 0 };
        cache.set(key, empty);
        saveCache();
        return empty;
    }

    function getGenusFromTaxonomy(taxText) {
        if (!taxText) return null;
        const first = taxText.trim().split(/\s+/)[0];
        return first || null;
    }

    // Insert extended taxonomy node after the existing taxonomy dd or next to it.
    function attachExtended(node, info) {
        try {
            // avoid duplicating - check if next siblings already have GBIF data
            let sibling = node.nextSibling;
            while (sibling) {
                if (sibling.classList && sibling.classList.contains('ms-extended-taxonomy-row')) {
                    return; // already exists
                }
                if (sibling.tagName === 'DT') break; // found next dt, stop checking
                sibling = sibling.nextSibling;
            }
            
            // Only show if we have data
            if (!info.family && !info.order && !info.class) {
                return;
            }
            
            // Insert rows in the same style as the site: dt (label) + dd (value)
            const rowsToInsert = [];
            
            if (info.family) {
                const dt = document.createElement('dt');
                dt.className = 'col-3 text-left ms-extended-taxonomy-row';
                dt.textContent = 'Family:';
                const dd = document.createElement('dd');
                dd.className = 'col-9 ms-extended-taxonomy-row';
                dd.innerHTML = `<div>${info.family}</div>`;
                rowsToInsert.push(dt, dd);
            }
            
            if (info.order) {
                const dt = document.createElement('dt');
                dt.className = 'col-3 text-left ms-extended-taxonomy-row';
                dt.textContent = 'Order:';
                const dd = document.createElement('dd');
                dd.className = 'col-9 ms-extended-taxonomy-row';
                dd.innerHTML = `<div>${info.order}</div>`;
                rowsToInsert.push(dt, dd);
            }
            
            if (info.class) {
                const dt = document.createElement('dt');
                dt.className = 'col-3 text-left ms-extended-taxonomy-row';
                dt.textContent = 'Class:';
                const dd = document.createElement('dd');
                dd.className = 'col-9 ms-extended-taxonomy-row';
                dd.innerHTML = `<div>${info.class}</div>`;
                rowsToInsert.push(dt, dd);
            }
            
            // Insert all rows after the taxonomy dd node
            if (node.parentNode && rowsToInsert.length > 0) {
                let insertAfter = node;
                rowsToInsert.forEach(row => {
                    insertAfter.parentNode.insertBefore(row, insertAfter.nextSibling);
                    insertAfter = row;
                });
            }
        } catch (e) {
            console.error('attachExtended error', e);
        }
    }

    // Insert extended taxonomy for show-page row layout (div.row with .showcase-label / .showcase-value)
    function attachExtendedRow(labelDiv, valueDiv, info) {
        try {
            // labelDiv is the left column, valueDiv is the right column inside a .row
            const row = labelDiv.closest('.row');
            if (!row) return;

            // avoid duplicating - check next sibling rows
            let next = row.nextElementSibling;
            while (next) {
                if (next.classList && next.classList.contains('ms-extended-taxonomy-row')) return; // already exists
                // stop if we reach another main field row (assume labels are showcase-label)
                if (next.querySelector && next.querySelector('.showcase-label')) break;
                next = next.nextElementSibling;
            }

            // Only show if we have data
            if (!info.family && !info.order && !info.class) return;

            const rowsToInsert = [];

            function makeRow(labelText, valueText) {
                const r = document.createElement('div');
                r.className = 'row ms-extended-taxonomy-row';
                const l = document.createElement('div');
                l.className = 'col-6 showcase-label';
                l.textContent = labelText;
                const v = document.createElement('div');
                v.className = 'col-6 showcase-value';
                const inner = document.createElement('div');
                inner.textContent = valueText;
                v.appendChild(inner);
                r.appendChild(l);
                r.appendChild(v);
                return r;
            }

            if (info.family) rowsToInsert.push(makeRow('Family', info.family));
            if (info.order) rowsToInsert.push(makeRow('Order', info.order));
            if (info.class) rowsToInsert.push(makeRow('Class', info.class));

            // Insert after the current row
            let insertAfter = row;
            rowsToInsert.forEach(r => {
                insertAfter.parentNode.insertBefore(r, insertAfter.nextSibling);
                insertAfter = r;
            });
        } catch (e) {
            console.error('attachExtendedRow error', e);
        }
    }

    async function processAll() {
        loadCache();
        // Process search/listing items (li.document)
        const items = document.querySelectorAll('li.document');
        for (const item of items) {
            try {
                // skip items we've already annotated
                if (item.dataset && item.dataset.msGbif === '1') {
                    continue;
                }

                const tax = (function() {
                    // reuse previous logic: dt with Taxonomy then dd
                    const dt = Array.from(item.querySelectorAll('dt')).find(d => d.textContent && d.textContent.trim().startsWith('Taxonomy'));
                    const dd = dt ? dt.nextElementSibling : null;
                    if (dd) {
                        const i = dd.querySelector('i');
                        return i ? i.textContent.trim() : dd.textContent.trim();
                    }
                    const fallback = Array.from(item.querySelectorAll('dd')).find(d => d.previousElementSibling && d.previousElementSibling.textContent && d.previousElementSibling.textContent.includes('Taxonomy'));
                    if (fallback) return (fallback.querySelector('i') ? fallback.querySelector('i').textContent.trim() : fallback.textContent.trim());
                    return null;
                })();

                const genus = getGenusFromTaxonomy(tax);

                if (!genus) {
                    continue;
                }

                const info = await fetchGbifForGenus(genus);

                // attach next to the taxonomy dd (reuse earlier found dd if possible)
                const dt = Array.from(item.querySelectorAll('dt')).find(d => d.textContent && d.textContent.trim().startsWith('Taxonomy'));
                const dd = dt ? dt.nextElementSibling : null;
                const attachNode = dd || (Array.from(item.querySelectorAll('dd')).find(d => d.previousElementSibling && d.previousElementSibling.textContent && d.previousElementSibling.textContent.includes('Taxonomy')));

                if (attachNode) {
                    attachExtended(attachNode, info);
                    try { item.dataset.msGbif = '1'; } catch (e) { /* ignore */ }
                }
            } catch (e) {
                console.error('GBIF processAll item error', e);
            }
        }

        // Additionally, if we're on an individual media page (General details), find the Taxonomy field and attach there
        try {
            // The item/show page uses a dl list with dt labels like 'General details' and nested dts/dds.
            // Find any dt that contains 'Taxonomy' text (case-insensitive) within the document and that is part of the general details area.
            const dtAll = Array.from(document.querySelectorAll('dt'));
            for (const dt of dtAll) {
                try {
                    if (!dt.textContent) continue;
                    const txt = dt.textContent.trim();
                    if (!/Taxonomy/i.test(txt)) continue;

                    // determine the dd with the taxonomy value
                    const dd = dt.nextElementSibling;
                    if (!dd) continue;

                    // avoid adding multiple times
                    let parentLi = dt.closest('li.document');
                    if (parentLi && parentLi.dataset && parentLi.dataset.msGbif === '1') continue;

                    const taxText = (dd.querySelector('i') ? dd.querySelector('i').textContent.trim() : dd.textContent.trim());
                    const genus = getGenusFromTaxonomy(taxText);
                    if (!genus) continue;

                    const info = await fetchGbifForGenus(genus);
                    attachExtended(dd, info);
                    try { if (parentLi) parentLi.dataset.msGbif = '1'; } catch (e) { /* ignore */ }
                } catch (e) { /* ignore per-dt errors */ }
            }
        } catch (e) {
            console.error('GBIF processAll page-level taxonomy error', e);
        }

        // Also support the .row / .showcase-label layout used in some media pages
        try {
            const labels = Array.from(document.querySelectorAll('.showcase-label'));
            for (const labelDiv of labels) {
                try {
                    const txt = labelDiv.textContent && labelDiv.textContent.trim();
                    if (!txt) continue;
                    if (!/Taxonomy/i.test(txt)) continue; // match 'Object taxonomy' or similar

                    // find the adjacent value column
                    const row = labelDiv.closest('.row');
                    if (!row) continue;
                    const valueDiv = row.querySelector('.showcase-value');
                    if (!valueDiv) continue;

                    // avoid duplicates
                    if (row.nextElementSibling && row.nextElementSibling.classList && row.nextElementSibling.classList.contains('ms-extended-taxonomy-row')) continue;

                    const taxText = (valueDiv.querySelector('i') ? valueDiv.querySelector('i').textContent.trim() : valueDiv.textContent.trim());
                    const genus = getGenusFromTaxonomy(taxText);
                    if (!genus) continue;
                    const info = await fetchGbifForGenus(genus);
                    attachExtendedRow(labelDiv, valueDiv, info);
                } catch (e) { /* ignore per-label errors */ }
            }
        } catch (e) {
            console.error('GBIF processAll showcase-row error', e);
        }
    }

    // observe mutations and process newly added results
    const mo = new MutationObserver((mutations) => {
        // small debounce
        if (window.__morpho_gbif_timeout) clearTimeout(window.__morpho_gbif_timeout);
        window.__morpho_gbif_timeout = setTimeout(() => { processAll(); }, 250);
    });
    mo.observe(document.body, { childList: true, subtree: true });

    // run once
    setTimeout(() => { processAll(); }, 300);

})();
